# Dataset Specifications with Pydantic

This module provides Pydantic model specifications for common datasets available in `dbldatagen.datasets`. These models can be used for type validation, API schemas, and documentation.

## Available Models

### BasicUser
Represents user data with customer information:
- `customer_id`: Unique customer identifier (integer >= 1000000)
- `name`: Customer name (string)
- `email`: Email address (string)
- `ip_addr`: IP address (string)
- `phone`: Phone number (string)

### BasicStockTicker
Represents stock ticker time-series data:
- `symbol`: Stock ticker symbol (string, 1-10 characters)
- `post_date`: Trading date (date)
- `open`: Opening price (Decimal >= 0, 2 decimal places)
- `close`: Closing price (Decimal >= 0, 2 decimal places)
- `high`: Highest price (Decimal >= 0, 2 decimal places)
- `low`: Lowest price (Decimal >= 0, 2 decimal places)
- `adj_close`: Adjusted closing price (Decimal >= 0, 2 decimal places)
- `volume`: Trading volume (integer >= 0)

## Usage

### Basic Usage

```python
from dbldatagen.datasets_with_specs import BasicUser, BasicStockTicker
from datetime import date
from decimal import Decimal

# Create a user instance
user = BasicUser(
    customer_id=1234567890,
    name="John Doe",
    email="john.doe@example.com",
    ip_addr="192.168.1.100",
    phone="(555)-123-4567"
)

# Create a stock ticker instance
ticker = BasicStockTicker(
    symbol="AAPL",
    post_date=date(2024, 10, 15),
    open=Decimal("150.25"),
    close=Decimal("152.50"),
    high=Decimal("153.75"),
    low=Decimal("149.80"),
    adj_close=Decimal("152.35"),
    volume=2500000
)
```

### Validation

The models automatically validate data:

```python
# This will raise a validation error (customer_id too small)
try:
    user = BasicUser(
        customer_id=100,  # Must be >= 1000000
        name="Jane Doe",
        email="jane@example.com",
        ip_addr="10.0.0.1",
        phone="555-1234"
    )
except ValidationError as e:
    print(f"Validation failed: {e}")
```

### Serialization

```python
# Convert to dictionary
user_dict = user.dict()

# Convert to JSON
user_json = user.json()

# Parse from JSON
user_from_json = BasicUser.parse_raw(user_json)

# Get JSON schema
schema = BasicUser.schema_json(indent=2)
```

### Integration with FastAPI

```python
from fastapi import FastAPI
from dbldatagen.datasets_with_specs import BasicUser

app = FastAPI()

@app.post("/users/")
async def create_user(user: BasicUser):
    # FastAPI will automatically validate the request body
    return {"user_id": user.customer_id, "name": user.name}
```

### Integration with Pandas

```python
import pandas as pd
from dbldatagen.datasets_with_specs import BasicStockTicker

# Create DataFrame from Pydantic models
tickers = [
    BasicStockTicker(...),
    BasicStockTicker(...),
]

df = pd.DataFrame([ticker.dict() for ticker in tickers])
```

## Correspondence with Data Generators

These models correspond to the data generated by the providers in `dbldatagen.datasets`:

- `BasicUser` ↔ `BasicUserProvider` (dataset name: "basic/user")
- `BasicStockTicker` ↔ `BasicStockTickerProvider` (dataset name: "basic/stock_ticker")

The Pydantic models define the schema and validation rules, while the providers generate the actual data using the dbldatagen framework.

## Benefits

1. **Type Safety**: Catch type errors at development time
2. **Validation**: Automatic data validation with detailed error messages
3. **Documentation**: Self-documenting code with field descriptions
4. **API Integration**: Direct integration with FastAPI and other Pydantic-based frameworks
5. **Schema Generation**: Generate JSON schemas for documentation and code generation
6. **IDE Support**: Better autocomplete and type hints in IDEs

## Requirements

- Python 3.8+
- Pydantic 1.x or 2.x (with v1 compatibility layer)

The module uses the compatibility layer in `dbldatagen.spec.compat` to work with both Pydantic v1 and v2.

